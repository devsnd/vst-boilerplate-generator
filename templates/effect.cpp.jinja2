//------------------------------------------------------------------------------
// Generated by VST Boilerplate Generator
//------------------------------------------------------------------------------

#include "effect.h"

//------------------------------------------------------------------------------
AudioEffect* createEffectInstance (audioMasterCallback audioMaster)
{
    return new {{ effect.class_name() }} (audioMaster);
}

//------------------------------------------------------------------------------
{{ effect.class_name() }}::{{ effect.class_name() }} (audioMasterCallback audioMaster)
: AudioEffectX (audioMaster, 1, {{ effect.config.parameters|count }})  // program count, parameter count
{
    setNumInputs ( {{ effect.config.input_channels }} );
    setNumOutputs ( {{ effect.config.output_channels }} );
    setUniqueID ( {{ effect.config.unique_id }} );
    canProcessReplacing (); // supports replacing output
    canDoubleReplacing ();  // supports double precision processing
    vst_strncpy (programName, "{{ effect.config.program_name }}", kVstMaxProgNameLen);
}

//------------------------------------------------------------------------------
{{ effect.class_name() }}::~{{ effect.class_name() }} ()
{

}

//------------------------------------------------------------------------------
void {{ effect.class_name() }}::setProgramName (char* name)
{
    vst_strncpy (programName, name, kVstMaxProgNameLen);
}

//------------------------------------------------------------------------------
void {{ effect.class_name() }}::getProgramName (char* name)
{
    vst_strncpy (name, programName, kVstMaxProgNameLen);
}

//------------------------------------------------------------------------------
void {{ effect.class_name() }}::setParameter (VstInt32 index, float value)
{
    {% for parameter in effect.config.parameters %}
    if(index == {{ loop.index0 }}){
        parameter_{{parameter.variable_name}} = value;
    }
    {% endfor %}
}

//------------------------------------------------------------------------------
float {{ effect.class_name() }}::getParameter (VstInt32 index)
{
    {% for parameter in effect.config.parameters %}
    if(index == {{ loop.index0 }}){
        return parameter_{{parameter.variable_name}};
    }
    {% endfor %}

    return 0.0f;
}

//------------------------------------------------------------------------------
void {{ effect.class_name() }}::getParameterName (VstInt32 index, char* label)
{
    {% for parameter in effect.config.parameters %}
    if(index == {{ loop.index0 }}){
        vst_strncpy (label, "{{ parameter.name }}", kVstMaxParamStrLen);
        return;
    }
    {% endfor %}
    vst_strncpy (label, "MISSING NAME", kVstMaxParamStrLen);
}

//------------------------------------------------------------------------------
void {{ effect.class_name() }}::getParameterDisplay (VstInt32 index, char* text)
{
    dB2string (0, text, kVstMaxParamStrLen);
}

//------------------------------------------------------------------------------
void {{ effect.class_name() }}::getParameterLabel (VstInt32 index, char* label)
{
    {% for parameter in effect.config.parameters %}
    if(index == {{ loop.index0 }}){
        vst_strncpy (label, "{{ parameter.label }}", kVstMaxParamStrLen);
        return;
    }
    {% endfor %}
    vst_strncpy (label, "MISSING LABEL", kVstMaxParamStrLen);
}

//------------------------------------------------------------------------
bool {{ effect.class_name() }}::getEffectName (char* name)
{
    vst_strncpy (name, "{{ effect.config.effect_name }}", kVstMaxEffectNameLen);
    return true;
}

//------------------------------------------------------------------------
bool {{ effect.class_name() }}::getProductString (char* text)
{
    vst_strncpy (text, "{{ effect.config.product_name }}", kVstMaxProductStrLen);
    return true;
}

//------------------------------------------------------------------------
bool {{ effect.class_name() }}::getVendorString (char* text)
{
    vst_strncpy (text, "{{ effect.config.vendor_name }}", kVstMaxVendorStrLen);
    return true;
}

//------------------------------------------------------------------------------
VstInt32 {{ effect.class_name() }}::getVendorVersion ()
{ 
    return {{ effect.config.vendor_version }}; 
}

//------------------------------------------------------------------------------
void {{ effect.class_name() }}::processReplacing (float** inputs, float** outputs, VstInt32 sampleFrames)
{

    {% for channel in range(effect.config.input_channels) %}
    float* in{{ channel }}  =  inputs[{{ channel }}];
    {% endfor %}
    {% for channel in range(effect.config.output_channels) %}
    float* out{{channel}} = outputs[ {{channel}} ];
    {% endfor %}

    // VST Scaffold: just pipe through a stereo signal:
    //
    // This is where your effect logic goes.
    while (--sampleFrames >= 0)
    {
        (*out0++) = (*in0++);
        (*out1++) = (*in1++);
    }
}

//------------------------------------------------------------------------------
void {{ effect.class_name() }}::processDoubleReplacing (double** inputs, double** outputs, VstInt32 sampleFrames)
{
    {% for channel in range(effect.config.input_channels) %}
    double* in{{ channel }}  =  inputs[{{ channel }}];
    {% endfor %}
    {% for channel in range(effect.config.output_channels) %}
    double* out{{channel}} = outputs[ {{channel}} ];
    {% endfor %}

    // VST Scaffold: just pipe through a stereo signal:
    //
    // This is where your effect logic goes.
    while (--sampleFrames >= 0)
    {
        (*out0++) = (*in0++);
        (*out1++) = (*in1++);
    }
}
